"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_sc_server_node_modules_langchain_dist_chains_sequential_chain_js";
exports.ids = ["_sc_server_node_modules_langchain_dist_chains_sequential_chain_js"];
exports.modules = {

/***/ "(sc_server)/./node_modules/langchain/dist/chains/sequential_chain.js":
/*!****************************************************************!*\
  !*** ./node_modules/langchain/dist/chains/sequential_chain.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SequentialChain: () => (/* binding */ SequentialChain),\n/* harmony export */   SimpleSequentialChain: () => (/* binding */ SimpleSequentialChain)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"(sc_server)/./node_modules/langchain/dist/chains/base.js\");\n/* harmony import */ var _util_set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/set.js */ \"(sc_server)/./node_modules/langchain/dist/util/set.js\");\n\n\nfunction formatSet(input) {\n    return Array.from(input).map((i)=>`\"${i}\"`).join(\", \");\n}\n/**\n * Chain where the outputs of one chain feed directly into next.\n */ class SequentialChain extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseChain {\n    get inputKeys() {\n        return this.inputVariables;\n    }\n    get outputKeys() {\n        return this.outputVariables;\n    }\n    constructor(fields){\n        super(fields);\n        Object.defineProperty(this, \"chains\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"returnAll\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chains = fields.chains;\n        this.inputVariables = fields.inputVariables;\n        this.outputVariables = fields.outputVariables ?? [];\n        if (this.outputVariables.length > 0 && fields.returnAll) {\n            throw new Error(\"Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.\");\n        }\n        this.returnAll = fields.returnAll ?? false;\n        this._validateChains();\n    }\n    /** @ignore */ _validateChains() {\n        if (this.chains.length === 0) {\n            throw new Error(\"Sequential chain must have at least one chain.\");\n        }\n        const memoryKeys = this.memory?.memoryKeys ?? [];\n        const inputKeysSet = new Set(this.inputKeys);\n        const memoryKeysSet = new Set(memoryKeys);\n        const keysIntersection = (0,_util_set_js__WEBPACK_IMPORTED_MODULE_1__.intersection)(inputKeysSet, memoryKeysSet);\n        if (keysIntersection.size > 0) {\n            throw new Error(`The following keys: ${formatSet(keysIntersection)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);\n        }\n        const availableKeys = (0,_util_set_js__WEBPACK_IMPORTED_MODULE_1__.union)(inputKeysSet, memoryKeysSet);\n        for (const chain of this.chains){\n            const missingKeys = (0,_util_set_js__WEBPACK_IMPORTED_MODULE_1__.difference)(new Set(chain.inputKeys), availableKeys);\n            if (missingKeys.size > 0) {\n                throw new Error(`Missing variables for chain \"${chain._chainType()}\": ${formatSet(missingKeys)}. Only got the following variables: ${formatSet(availableKeys)}.`);\n            }\n            const outputKeysSet = new Set(chain.outputKeys);\n            const overlappingOutputKeys = (0,_util_set_js__WEBPACK_IMPORTED_MODULE_1__.intersection)(availableKeys, outputKeysSet);\n            if (overlappingOutputKeys.size > 0) {\n                throw new Error(`The following output variables for chain \"${chain._chainType()}\" are overlapping: ${formatSet(overlappingOutputKeys)}. This can lead to unexpected behaviour.`);\n            }\n            for (const outputKey of outputKeysSet){\n                availableKeys.add(outputKey);\n            }\n        }\n        if (this.outputVariables.length === 0) {\n            if (this.returnAll) {\n                const outputKeys = (0,_util_set_js__WEBPACK_IMPORTED_MODULE_1__.difference)(availableKeys, inputKeysSet);\n                this.outputVariables = Array.from(outputKeys);\n            } else {\n                this.outputVariables = this.chains[this.chains.length - 1].outputKeys;\n            }\n        } else {\n            const missingKeys = (0,_util_set_js__WEBPACK_IMPORTED_MODULE_1__.difference)(new Set(this.outputVariables), new Set(availableKeys));\n            if (missingKeys.size > 0) {\n                throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${formatSet(missingKeys)}.`);\n            }\n        }\n    }\n    /** @ignore */ async _call(values, runManager) {\n        let input = {};\n        const allChainValues = values;\n        let i = 0;\n        for (const chain of this.chains){\n            i += 1;\n            input = await chain.call(allChainValues, runManager?.getChild(`step_${i}`));\n            for (const key of Object.keys(input)){\n                allChainValues[key] = input[key];\n            }\n        }\n        const output = {};\n        for (const key of this.outputVariables){\n            output[key] = allChainValues[key];\n        }\n        return output;\n    }\n    _chainType() {\n        return \"sequential_chain\";\n    }\n    static async deserialize(data) {\n        const chains = [];\n        const inputVariables = data.input_variables;\n        const outputVariables = data.output_variables;\n        const serializedChains = data.chains;\n        for (const serializedChain of serializedChains){\n            const deserializedChain = await _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseChain.deserialize(serializedChain);\n            chains.push(deserializedChain);\n        }\n        return new SequentialChain({\n            chains,\n            inputVariables,\n            outputVariables\n        });\n    }\n    serialize() {\n        const chains = [];\n        for (const chain of this.chains){\n            chains.push(chain.serialize());\n        }\n        return {\n            _type: this._chainType(),\n            input_variables: this.inputVariables,\n            output_variables: this.outputVariables,\n            chains\n        };\n    }\n}\n/**\n * Simple chain where a single string output of one chain is fed directly into the next.\n * @augments BaseChain\n * @augments SimpleSequentialChainInput\n *\n * @example\n * ```ts\n * import { SimpleSequentialChain, LLMChain } from \"langchain/chains\";\n * import { OpenAI } from \"langchain/llms/openai\";\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * // This is an LLMChain to write a synopsis given a title of a play.\n * const llm = new OpenAI({ temperature: 0 });\n * const template = `You are a playwright. Given the title of play, it is your job to write a synopsis for that title.\n *\n * Title: {title}\n * Playwright: This is a synopsis for the above play:`\n * const promptTemplate = new PromptTemplate({ template, inputVariables: [\"title\"] });\n * const synopsisChain = new LLMChain({ llm, prompt: promptTemplate });\n *\n *\n * // This is an LLMChain to write a review of a play given a synopsis.\n * const reviewLLM = new OpenAI({ temperature: 0 })\n * const reviewTemplate = `You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.\n *\n * Play Synopsis:\n * {synopsis}\n * Review from a New York Times play critic of the above play:`\n * const reviewPromptTemplate = new PromptTemplate({ template: reviewTemplate, inputVariables: [\"synopsis\"] });\n * const reviewChain = new LLMChain({ llm: reviewLLM, prompt: reviewPromptTemplate });\n *\n * const overallChain = new SimpleSequentialChain({chains: [synopsisChain, reviewChain], verbose:true})\n * const review = await overallChain.run(\"Tragedy at sunset on the beach\")\n * // the variable review contains resulting play review.\n * ```\n */ class SimpleSequentialChain extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseChain {\n    get inputKeys() {\n        return [\n            this.inputKey\n        ];\n    }\n    get outputKeys() {\n        return [\n            this.outputKey\n        ];\n    }\n    constructor(fields){\n        super(fields);\n        Object.defineProperty(this, \"chains\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"input\"\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"output\"\n        });\n        Object.defineProperty(this, \"trimOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chains = fields.chains;\n        this.trimOutputs = fields.trimOutputs ?? false;\n        this._validateChains();\n    }\n    /** @ignore */ _validateChains() {\n        for (const chain of this.chains){\n            if (chain.inputKeys.filter((k)=>!chain.memory?.memoryKeys.includes(k) ?? true).length !== 1) {\n                throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${chain.inputKeys.length} for ${chain._chainType()}.`);\n            }\n            if (chain.outputKeys.length !== 1) {\n                throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${chain.outputKeys.length} for ${chain._chainType()}.`);\n            }\n        }\n    }\n    /** @ignore */ async _call(values, runManager) {\n        let input = values[this.inputKey];\n        let i = 0;\n        for (const chain of this.chains){\n            i += 1;\n            input = (await chain.call({\n                [chain.inputKeys[0]]: input,\n                signal: values.signal\n            }, runManager?.getChild(`step_${i}`)))[chain.outputKeys[0]];\n            if (this.trimOutputs) {\n                input = input.trim();\n            }\n            await runManager?.handleText(input);\n        }\n        return {\n            [this.outputKey]: input\n        };\n    }\n    _chainType() {\n        return \"simple_sequential_chain\";\n    }\n    static async deserialize(data) {\n        const chains = [];\n        const serializedChains = data.chains;\n        for (const serializedChain of serializedChains){\n            const deserializedChain = await _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseChain.deserialize(serializedChain);\n            chains.push(deserializedChain);\n        }\n        return new SimpleSequentialChain({\n            chains\n        });\n    }\n    serialize() {\n        const chains = [];\n        for (const chain of this.chains){\n            chains.push(chain.serialize());\n        }\n        return {\n            _type: this._chainType(),\n            chains\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvY2hhaW5zL3NlcXVlbnRpYWxfY2hhaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzQztBQUMyQjtBQUNqRSxTQUFTSSxVQUFVQyxLQUFLO0lBQ3BCLE9BQU9DLE1BQU1DLEtBQUtGLE9BQ2JHLElBQUksQ0FBQ0MsSUFBTSxDQUFDLENBQUMsRUFBRUEsRUFBRSxDQUFDLENBQUMsRUFDbkJDLEtBQUs7QUFDZDtBQUNBOztDQUVDLEdBQ00sTUFBTUMsd0JBQXdCWCwrQ0FBU0E7SUFDMUMsSUFBSVksWUFBWTtRQUNaLE9BQU8sSUFBSSxDQUFDQztJQUNoQjtJQUNBLElBQUlDLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQ0M7SUFDaEI7SUFDQUMsWUFBWUMsTUFBTSxDQUFFO1FBQ2hCLEtBQUssQ0FBQ0E7UUFDTkMsT0FBT0MsZUFBZSxJQUFJLEVBQUUsVUFBVTtZQUNsQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGVBQWUsSUFBSSxFQUFFLGtCQUFrQjtZQUMxQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGVBQWUsSUFBSSxFQUFFLG1CQUFtQjtZQUMzQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGVBQWUsSUFBSSxFQUFFLGFBQWE7WUFDckNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ0MsU0FBU1AsT0FBT087UUFDckIsSUFBSSxDQUFDWCxpQkFBaUJJLE9BQU9KO1FBQzdCLElBQUksQ0FBQ0Usa0JBQWtCRSxPQUFPRixtQkFBbUIsRUFBRTtRQUNuRCxJQUFJLElBQUksQ0FBQ0EsZ0JBQWdCVSxTQUFTLEtBQUtS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QUFTLElBQUksQ0FBQ2IsT0FBUTtZQUM3QmYsS0FBSztZQUNMSixRQUFRLENBQUMsTUFBTWdDLE1BQU1XLEtBQUs7Z0JBQUUsQ0FBQ1gsTUFBTXpCLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRVA7Z0JBQU9nRSxRQUFReEIsT0FBT3dCO1lBQU8sR0FBR3ZCLFlBQVlHLFNBQVMsQ0FBQyxLQUFLLEVBQUV4QyxFQUFFLENBQUMsRUFBQyxDQUFFLENBQUM0QixNQUFNdkIsVUFBVSxDQUFDLEVBQUUsQ0FBQztZQUMxSSxJQUFJLElBQUksQ0FBQ21ELGFBQWE7Z0JBQ2xCNUQsUUFBUUEsTUFBTWlFO1lBQ2xCO1lBQ0EsTUFBTXhCLFlBQVl5QixXQUFXbEU7UUFDakM7UUFDQSxPQUFPO1lBQUUsQ0FBQyxJQUFJLENBQUNxQyxVQUFVLEVBQUVyQztRQUFNO0lBQ3JDO0lBQ0FrQyxhQUFhO1FBQ1QsT0FBTztJQUNYO0lBQ0EsYUFBYWMsWUFBWUMsSUFBSSxFQUFFO1FBQzNCLE1BQU05QixTQUFTLEVBQUU7UUFDakIsTUFBTWlDLG1CQUFtQkgsS0FBSzlCO1FBQzlCLEtBQUssTUFBTWtDLG1CQUFtQkQsaUJBQWtCO1lBQzVDLE1BQU1FLG9CQUFvQixNQUFNM0QsK0NBQVNBLENBQUNxRCxZQUFZSztZQUN0RGxDLE9BQU9vQyxLQUFLRDtRQUNoQjtRQUNBLE9BQU8sSUFBSUksc0JBQXNCO1lBQUV2QztRQUFPO0lBQzlDO0lBQ0FxQyxZQUFZO1FBQ1IsTUFBTXJDLFNBQVMsRUFBRTtRQUNqQixLQUFLLE1BQU1hLFNBQVMsSUFBSSxDQUFDYixPQUFRO1lBQzdCQSxPQUFPb0MsS0FBS3ZCLE1BQU13QjtRQUN0QjtRQUNBLE9BQU87WUFDSEMsT0FBTyxJQUFJLENBQUN2QjtZQUNaZjtRQUNKO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL21vb2QvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvY2hhaW5zL3NlcXVlbnRpYWxfY2hhaW4uanM/Y2YzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ2hhaW4gfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBpbnRlcnNlY3Rpb24sIHVuaW9uLCBkaWZmZXJlbmNlIH0gZnJvbSBcIi4uL3V0aWwvc2V0LmpzXCI7XG5mdW5jdGlvbiBmb3JtYXRTZXQoaW5wdXQpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShpbnB1dClcbiAgICAgICAgLm1hcCgoaSkgPT4gYFwiJHtpfVwiYClcbiAgICAgICAgLmpvaW4oXCIsIFwiKTtcbn1cbi8qKlxuICogQ2hhaW4gd2hlcmUgdGhlIG91dHB1dHMgb2Ygb25lIGNoYWluIGZlZWQgZGlyZWN0bHkgaW50byBuZXh0LlxuICovXG5leHBvcnQgY2xhc3MgU2VxdWVudGlhbENoYWluIGV4dGVuZHMgQmFzZUNoYWluIHtcbiAgICBnZXQgaW5wdXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dFZhcmlhYmxlcztcbiAgICB9XG4gICAgZ2V0IG91dHB1dEtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dFZhcmlhYmxlcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYWluc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dFZhcmlhYmxlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRWYXJpYWJsZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmV0dXJuQWxsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhaW5zID0gZmllbGRzLmNoYWlucztcbiAgICAgICAgdGhpcy5pbnB1dFZhcmlhYmxlcyA9IGZpZWxkcy5pbnB1dFZhcmlhYmxlcztcbiAgICAgICAgdGhpcy5vdXRwdXRWYXJpYWJsZXMgPSBmaWVsZHMub3V0cHV0VmFyaWFibGVzID8/IFtdO1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRWYXJpYWJsZXMubGVuZ3RoID4gMCAmJiBmaWVsZHMucmV0dXJuQWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgc3BlY2lmeSB2YXJpYWJsZXMgdG8gcmV0dXJuIHVzaW5nIGBvdXRwdXRWYXJpYWJsZXNgIG9yIHVzZSBgcmV0dXJuQWxsYCBwYXJhbS4gQ2Fubm90IGFwcGx5IGJvdGggY29uZGl0aW9ucyBhdCB0aGUgc2FtZSB0aW1lLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHVybkFsbCA9IGZpZWxkcy5yZXR1cm5BbGwgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlQ2hhaW5zKCk7XG4gICAgfVxuICAgIC8qKiBAaWdub3JlICovXG4gICAgX3ZhbGlkYXRlQ2hhaW5zKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFpbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXF1ZW50aWFsIGNoYWluIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgY2hhaW4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lbW9yeUtleXMgPSB0aGlzLm1lbW9yeT8ubWVtb3J5S2V5cyA/PyBbXTtcbiAgICAgICAgY29uc3QgaW5wdXRLZXlzU2V0ID0gbmV3IFNldCh0aGlzLmlucHV0S2V5cyk7XG4gICAgICAgIGNvbnN0IG1lbW9yeUtleXNTZXQgPSBuZXcgU2V0KG1lbW9yeUtleXMpO1xuICAgICAgICBjb25zdCBrZXlzSW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uKGlucHV0S2V5c1NldCwgbWVtb3J5S2V5c1NldCk7XG4gICAgICAgIGlmIChrZXlzSW50ZXJzZWN0aW9uLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcga2V5czogJHtmb3JtYXRTZXQoa2V5c0ludGVyc2VjdGlvbil9IGFyZSBvdmVybGFwcGluZyBiZXR3ZWVuIG1lbW9yeSBhbmQgaW5wdXQga2V5cyBvZiB0aGUgY2hhaW4gdmFyaWFibGVzLiBUaGlzIGNhbiBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLiBQbGVhc2UgdXNlIGlucHV0IGFuZCBtZW1vcnkga2V5cyB0aGF0IGRvbid0IG92ZXJsYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXZhaWxhYmxlS2V5cyA9IHVuaW9uKGlucHV0S2V5c1NldCwgbWVtb3J5S2V5c1NldCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hhaW4gb2YgdGhpcy5jaGFpbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdLZXlzID0gZGlmZmVyZW5jZShuZXcgU2V0KGNoYWluLmlucHV0S2V5cyksIGF2YWlsYWJsZUtleXMpO1xuICAgICAgICAgICAgaWYgKG1pc3NpbmdLZXlzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHZhcmlhYmxlcyBmb3IgY2hhaW4gXCIke2NoYWluLl9jaGFpblR5cGUoKX1cIjogJHtmb3JtYXRTZXQobWlzc2luZ0tleXMpfS4gT25seSBnb3QgdGhlIGZvbGxvd2luZyB2YXJpYWJsZXM6ICR7Zm9ybWF0U2V0KGF2YWlsYWJsZUtleXMpfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEtleXNTZXQgPSBuZXcgU2V0KGNoYWluLm91dHB1dEtleXMpO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdPdXRwdXRLZXlzID0gaW50ZXJzZWN0aW9uKGF2YWlsYWJsZUtleXMsIG91dHB1dEtleXNTZXQpO1xuICAgICAgICAgICAgaWYgKG92ZXJsYXBwaW5nT3V0cHV0S2V5cy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBvdXRwdXQgdmFyaWFibGVzIGZvciBjaGFpbiBcIiR7Y2hhaW4uX2NoYWluVHlwZSgpfVwiIGFyZSBvdmVybGFwcGluZzogJHtmb3JtYXRTZXQob3ZlcmxhcHBpbmdPdXRwdXRLZXlzKX0uIFRoaXMgY2FuIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvdXIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG91dHB1dEtleSBvZiBvdXRwdXRLZXlzU2V0KSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlS2V5cy5hZGQob3V0cHV0S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRwdXRWYXJpYWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXR1cm5BbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRLZXlzID0gZGlmZmVyZW5jZShhdmFpbGFibGVLZXlzLCBpbnB1dEtleXNTZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0VmFyaWFibGVzID0gQXJyYXkuZnJvbShvdXRwdXRLZXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0VmFyaWFibGVzID0gdGhpcy5jaGFpbnNbdGhpcy5jaGFpbnMubGVuZ3RoIC0gMV0ub3V0cHV0S2V5cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdLZXlzID0gZGlmZmVyZW5jZShuZXcgU2V0KHRoaXMub3V0cHV0VmFyaWFibGVzKSwgbmV3IFNldChhdmFpbGFibGVLZXlzKSk7XG4gICAgICAgICAgICBpZiAobWlzc2luZ0tleXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgb3V0cHV0IHZhcmlhYmxlcyB3ZXJlIGV4cGVjdGVkIHRvIGJlIGluIHRoZSBmaW5hbCBjaGFpbiBvdXRwdXQgYnV0IHdlcmUgbm90IGZvdW5kOiAke2Zvcm1hdFNldChtaXNzaW5nS2V5cyl9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaWdub3JlICovXG4gICAgYXN5bmMgX2NhbGwodmFsdWVzLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGxldCBpbnB1dCA9IHt9O1xuICAgICAgICBjb25zdCBhbGxDaGFpblZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGNoYWluIG9mIHRoaXMuY2hhaW5zKSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBpbnB1dCA9IGF3YWl0IGNoYWluLmNhbGwoYWxsQ2hhaW5WYWx1ZXMsIHJ1bk1hbmFnZXI/LmdldENoaWxkKGBzdGVwXyR7aX1gKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBhbGxDaGFpblZhbHVlc1trZXldID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5vdXRwdXRWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gYWxsQ2hhaW5WYWx1ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBfY2hhaW5UeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJzZXF1ZW50aWFsX2NoYWluXCI7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNoYWlucyA9IFtdO1xuICAgICAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IGRhdGEuaW5wdXRfdmFyaWFibGVzO1xuICAgICAgICBjb25zdCBvdXRwdXRWYXJpYWJsZXMgPSBkYXRhLm91dHB1dF92YXJpYWJsZXM7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGFpbnMgPSBkYXRhLmNoYWlucztcbiAgICAgICAgZm9yIChjb25zdCBzZXJpYWxpemVkQ2hhaW4gb2Ygc2VyaWFsaXplZENoYWlucykge1xuICAgICAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkQ2hhaW4gPSBhd2FpdCBCYXNlQ2hhaW4uZGVzZXJpYWxpemUoc2VyaWFsaXplZENoYWluKTtcbiAgICAgICAgICAgIGNoYWlucy5wdXNoKGRlc2VyaWFsaXplZENoYWluKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbnRpYWxDaGFpbih7IGNoYWlucywgaW5wdXRWYXJpYWJsZXMsIG91dHB1dFZhcmlhYmxlcyB9KTtcbiAgICB9XG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCBjaGFpbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjaGFpbiBvZiB0aGlzLmNoYWlucykge1xuICAgICAgICAgICAgY2hhaW5zLnB1c2goY2hhaW4uc2VyaWFsaXplKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfdHlwZTogdGhpcy5fY2hhaW5UeXBlKCksXG4gICAgICAgICAgICBpbnB1dF92YXJpYWJsZXM6IHRoaXMuaW5wdXRWYXJpYWJsZXMsXG4gICAgICAgICAgICBvdXRwdXRfdmFyaWFibGVzOiB0aGlzLm91dHB1dFZhcmlhYmxlcyxcbiAgICAgICAgICAgIGNoYWlucyxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIFNpbXBsZSBjaGFpbiB3aGVyZSBhIHNpbmdsZSBzdHJpbmcgb3V0cHV0IG9mIG9uZSBjaGFpbiBpcyBmZWQgZGlyZWN0bHkgaW50byB0aGUgbmV4dC5cbiAqIEBhdWdtZW50cyBCYXNlQ2hhaW5cbiAqIEBhdWdtZW50cyBTaW1wbGVTZXF1ZW50aWFsQ2hhaW5JbnB1dFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU2ltcGxlU2VxdWVudGlhbENoYWluLCBMTE1DaGFpbiB9IGZyb20gXCJsYW5nY2hhaW4vY2hhaW5zXCI7XG4gKiBpbXBvcnQgeyBPcGVuQUkgfSBmcm9tIFwibGFuZ2NoYWluL2xsbXMvb3BlbmFpXCI7XG4gKiBpbXBvcnQgeyBQcm9tcHRUZW1wbGF0ZSB9IGZyb20gXCJsYW5nY2hhaW4vcHJvbXB0c1wiO1xuICpcbiAqIC8vIFRoaXMgaXMgYW4gTExNQ2hhaW4gdG8gd3JpdGUgYSBzeW5vcHNpcyBnaXZlbiBhIHRpdGxlIG9mIGEgcGxheS5cbiAqIGNvbnN0IGxsbSA9IG5ldyBPcGVuQUkoeyB0ZW1wZXJhdHVyZTogMCB9KTtcbiAqIGNvbnN0IHRlbXBsYXRlID0gYFlvdSBhcmUgYSBwbGF5d3JpZ2h0LiBHaXZlbiB0aGUgdGl0bGUgb2YgcGxheSwgaXQgaXMgeW91ciBqb2IgdG8gd3JpdGUgYSBzeW5vcHNpcyBmb3IgdGhhdCB0aXRsZS5cbiAqXG4gKiBUaXRsZToge3RpdGxlfVxuICogUGxheXdyaWdodDogVGhpcyBpcyBhIHN5bm9wc2lzIGZvciB0aGUgYWJvdmUgcGxheTpgXG4gKiBjb25zdCBwcm9tcHRUZW1wbGF0ZSA9IG5ldyBQcm9tcHRUZW1wbGF0ZSh7IHRlbXBsYXRlLCBpbnB1dFZhcmlhYmxlczogW1widGl0bGVcIl0gfSk7XG4gKiBjb25zdCBzeW5vcHNpc0NoYWluID0gbmV3IExMTUNoYWluKHsgbGxtLCBwcm9tcHQ6IHByb21wdFRlbXBsYXRlIH0pO1xuICpcbiAqXG4gKiAvLyBUaGlzIGlzIGFuIExMTUNoYWluIHRvIHdyaXRlIGEgcmV2aWV3IG9mIGEgcGxheSBnaXZlbiBhIHN5bm9wc2lzLlxuICogY29uc3QgcmV2aWV3TExNID0gbmV3IE9wZW5BSSh7IHRlbXBlcmF0dXJlOiAwIH0pXG4gKiBjb25zdCByZXZpZXdUZW1wbGF0ZSA9IGBZb3UgYXJlIGEgcGxheSBjcml0aWMgZnJvbSB0aGUgTmV3IFlvcmsgVGltZXMuIEdpdmVuIHRoZSBzeW5vcHNpcyBvZiBwbGF5LCBpdCBpcyB5b3VyIGpvYiB0byB3cml0ZSBhIHJldmlldyBmb3IgdGhhdCBwbGF5LlxuICpcbiAqIFBsYXkgU3lub3BzaXM6XG4gKiB7c3lub3BzaXN9XG4gKiBSZXZpZXcgZnJvbSBhIE5ldyBZb3JrIFRpbWVzIHBsYXkgY3JpdGljIG9mIHRoZSBhYm92ZSBwbGF5OmBcbiAqIGNvbnN0IHJldmlld1Byb21wdFRlbXBsYXRlID0gbmV3IFByb21wdFRlbXBsYXRlKHsgdGVtcGxhdGU6IHJldmlld1RlbXBsYXRlLCBpbnB1dFZhcmlhYmxlczogW1wic3lub3BzaXNcIl0gfSk7XG4gKiBjb25zdCByZXZpZXdDaGFpbiA9IG5ldyBMTE1DaGFpbih7IGxsbTogcmV2aWV3TExNLCBwcm9tcHQ6IHJldmlld1Byb21wdFRlbXBsYXRlIH0pO1xuICpcbiAqIGNvbnN0IG92ZXJhbGxDaGFpbiA9IG5ldyBTaW1wbGVTZXF1ZW50aWFsQ2hhaW4oe2NoYWluczogW3N5bm9wc2lzQ2hhaW4sIHJldmlld0NoYWluXSwgdmVyYm9zZTp0cnVlfSlcbiAqIGNvbnN0IHJldmlldyA9IGF3YWl0IG92ZXJhbGxDaGFpbi5ydW4oXCJUcmFnZWR5IGF0IHN1bnNldCBvbiB0aGUgYmVhY2hcIilcbiAqIC8vIHRoZSB2YXJpYWJsZSByZXZpZXcgY29udGFpbnMgcmVzdWx0aW5nIHBsYXkgcmV2aWV3LlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTaW1wbGVTZXF1ZW50aWFsQ2hhaW4gZXh0ZW5kcyBCYXNlQ2hhaW4ge1xuICAgIGdldCBpbnB1dEtleXMoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5pbnB1dEtleV07XG4gICAgfVxuICAgIGdldCBvdXRwdXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMub3V0cHV0S2V5XTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYWluc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnB1dEtleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJpbnB1dFwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwib3V0cHV0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyaW1PdXRwdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhaW5zID0gZmllbGRzLmNoYWlucztcbiAgICAgICAgdGhpcy50cmltT3V0cHV0cyA9IGZpZWxkcy50cmltT3V0cHV0cyA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVDaGFpbnMoKTtcbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBfdmFsaWRhdGVDaGFpbnMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhaW4gb2YgdGhpcy5jaGFpbnMpIHtcbiAgICAgICAgICAgIGlmIChjaGFpbi5pbnB1dEtleXMuZmlsdGVyKChrKSA9PiAhY2hhaW4ubWVtb3J5Py5tZW1vcnlLZXlzLmluY2x1ZGVzKGspID8/IHRydWUpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhaW5zIHVzZWQgaW4gU2ltcGxlU2VxdWVudGlhbENoYWluIHNob3VsZCBhbGwgaGF2ZSBvbmUgaW5wdXQsIGdvdCAke2NoYWluLmlucHV0S2V5cy5sZW5ndGh9IGZvciAke2NoYWluLl9jaGFpblR5cGUoKX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhaW4ub3V0cHV0S2V5cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoYWlucyB1c2VkIGluIFNpbXBsZVNlcXVlbnRpYWxDaGFpbiBzaG91bGQgYWxsIGhhdmUgb25lIG91dHB1dCwgZ290ICR7Y2hhaW4ub3V0cHV0S2V5cy5sZW5ndGh9IGZvciAke2NoYWluLl9jaGFpblR5cGUoKX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhc3luYyBfY2FsbCh2YWx1ZXMsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gdmFsdWVzW3RoaXMuaW5wdXRLZXldO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgY2hhaW4gb2YgdGhpcy5jaGFpbnMpIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIGlucHV0ID0gKGF3YWl0IGNoYWluLmNhbGwoeyBbY2hhaW4uaW5wdXRLZXlzWzBdXTogaW5wdXQsIHNpZ25hbDogdmFsdWVzLnNpZ25hbCB9LCBydW5NYW5hZ2VyPy5nZXRDaGlsZChgc3RlcF8ke2l9YCkpKVtjaGFpbi5vdXRwdXRLZXlzWzBdXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyaW1PdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVUZXh0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBbdGhpcy5vdXRwdXRLZXldOiBpbnB1dCB9O1xuICAgIH1cbiAgICBfY2hhaW5UeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJzaW1wbGVfc2VxdWVudGlhbF9jaGFpblwiO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSkge1xuICAgICAgICBjb25zdCBjaGFpbnMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZENoYWlucyA9IGRhdGEuY2hhaW5zO1xuICAgICAgICBmb3IgKGNvbnN0IHNlcmlhbGl6ZWRDaGFpbiBvZiBzZXJpYWxpemVkQ2hhaW5zKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRDaGFpbiA9IGF3YWl0IEJhc2VDaGFpbi5kZXNlcmlhbGl6ZShzZXJpYWxpemVkQ2hhaW4pO1xuICAgICAgICAgICAgY2hhaW5zLnB1c2goZGVzZXJpYWxpemVkQ2hhaW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlU2VxdWVudGlhbENoYWluKHsgY2hhaW5zIH0pO1xuICAgIH1cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IGNoYWlucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNoYWluIG9mIHRoaXMuY2hhaW5zKSB7XG4gICAgICAgICAgICBjaGFpbnMucHVzaChjaGFpbi5zZXJpYWxpemUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9jaGFpblR5cGUoKSxcbiAgICAgICAgICAgIGNoYWlucyxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiQmFzZUNoYWluIiwiaW50ZXJzZWN0aW9uIiwidW5pb24iLCJkaWZmZXJlbmNlIiwiZm9ybWF0U2V0IiwiaW5wdXQiLCJBcnJheSIsImZyb20iLCJtYXAiLCJpIiwiam9pbiIsIlNlcXVlbnRpYWxDaGFpbiIsImlucHV0S2V5cyIsImlucHV0VmFyaWFibGVzIiwib3V0cHV0S2V5cyIsIm91dHB1dFZhcmlhYmxlcyIsImNvbnN0cnVjdG9yIiwiZmllbGRzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsImNoYWlucyIsImxlbmd0aCIsInJldHVybkFsbCIsIkVycm9yIiwiX3ZhbGlkYXRlQ2hhaW5zIiwibWVtb3J5S2V5cyIsIm1lbW9yeSIsImlucHV0S2V5c1NldCIsIlNldCIsIm1lbW9yeUtleXNTZXQiLCJrZXlzSW50ZXJzZWN0aW9uIiwic2l6ZSIsImF2YWlsYWJsZUtleXMiLCJjaGFpbiIsIm1pc3NpbmdLZXlzIiwiX2NoYWluVHlwZSIsIm91dHB1dEtleXNTZXQiLCJvdmVybGFwcGluZ091dHB1dEtleXMiLCJvdXRwdXRLZXkiLCJhZGQiLCJfY2FsbCIsInZhbHVlcyIsInJ1bk1hbmFnZXIiLCJhbGxDaGFpblZhbHVlcyIsImNhbGwiLCJnZXRDaGlsZCIsImtleSIsImtleXMiLCJvdXRwdXQiLCJkZXNlcmlhbGl6ZSIsImRhdGEiLCJpbnB1dF92YXJpYWJsZXMiLCJvdXRwdXRfdmFyaWFibGVzIiwic2VyaWFsaXplZENoYWlucyIsInNlcmlhbGl6ZWRDaGFpbiIsImRlc2VyaWFsaXplZENoYWluIiwicHVzaCIsInNlcmlhbGl6ZSIsIl90eXBlIiwiU2ltcGxlU2VxdWVudGlhbENoYWluIiwiaW5wdXRLZXkiLCJ0cmltT3V0cHV0cyIsImZpbHRlciIsImsiLCJpbmNsdWRlcyIsInNpZ25hbCIsInRyaW0iLCJoYW5kbGVUZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/langchain/dist/chains/sequential_chain.js\n");

/***/ }),

/***/ "(sc_server)/./node_modules/langchain/dist/util/set.js":
/*!*************************************************!*\
  !*** ./node_modules/langchain/dist/util/set.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   difference: () => (/* binding */ difference),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   union: () => (/* binding */ union)\n/* harmony export */ });\n/**\n * Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#implementing_basic_set_operations\n */ /**\n * returns intersection of two sets\n */ function intersection(setA, setB) {\n    const _intersection = new Set();\n    for (const elem of setB){\n        if (setA.has(elem)) {\n            _intersection.add(elem);\n        }\n    }\n    return _intersection;\n}\n/**\n * returns union of two sets\n */ function union(setA, setB) {\n    const _union = new Set(setA);\n    for (const elem of setB){\n        _union.add(elem);\n    }\n    return _union;\n}\n/**\n * returns difference of two sets\n */ function difference(setA, setB) {\n    const _difference = new Set(setA);\n    for (const elem of setB){\n        _difference.delete(elem);\n    }\n    return _difference;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX3NlcnZlcikvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvdXRpbC9zZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0NBRUMsR0FDRDs7Q0FFQyxHQUNNLFNBQVNBLGFBQWFDLElBQUksRUFBRUMsSUFBSTtJQUNuQyxNQUFNQyxnQkFBZ0IsSUFBSUM7SUFDMUIsS0FBSyxNQUFNQyxRQUFRSCxLQUFNO1FBQ3JCLElBQUlELEtBQUtLLElBQUlELE9BQU87WUFDaEJGLGNBQWNJLElBQUlGO1FBQ3RCO0lBQ0o7SUFDQSxPQUFPRjtBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTSyxNQUFNUCxJQUFJLEVBQUVDLElBQUk7SUFDNUIsTUFBTU8sU0FBUyxJQUFJTCxJQUFJSDtJQUN2QixLQUFLLE1BQU1JLFFBQVFILEtBQU07UUFDckJPLE9BQU9GLElBQUlGO0lBQ2Y7SUFDQSxPQUFPSTtBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTQyxXQUFXVCxJQUFJLEVBQUVDLElBQUk7SUFDakMsTUFBTVMsY0FBYyxJQUFJUCxJQUFJSDtJQUM1QixLQUFLLE1BQU1JLFFBQVFILEtBQU07UUFDckJTLFlBQVlDLE9BQU9QO0lBQ3ZCO0lBQ0EsT0FBT007QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL21vb2QvLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvdXRpbC9zZXQuanM/ZmQzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2V0I2ltcGxlbWVudGluZ19iYXNpY19zZXRfb3BlcmF0aW9uc1xuICovXG4vKipcbiAqIHJldHVybnMgaW50ZXJzZWN0aW9uIG9mIHR3byBzZXRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oc2V0QSwgc2V0Qikge1xuICAgIGNvbnN0IF9pbnRlcnNlY3Rpb24gPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIHNldEIpIHtcbiAgICAgICAgaWYgKHNldEEuaGFzKGVsZW0pKSB7XG4gICAgICAgICAgICBfaW50ZXJzZWN0aW9uLmFkZChlbGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2ludGVyc2VjdGlvbjtcbn1cbi8qKlxuICogcmV0dXJucyB1bmlvbiBvZiB0d28gc2V0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gdW5pb24oc2V0QSwgc2V0Qikge1xuICAgIGNvbnN0IF91bmlvbiA9IG5ldyBTZXQoc2V0QSk7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIHNldEIpIHtcbiAgICAgICAgX3VuaW9uLmFkZChlbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIF91bmlvbjtcbn1cbi8qKlxuICogcmV0dXJucyBkaWZmZXJlbmNlIG9mIHR3byBzZXRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmZXJlbmNlKHNldEEsIHNldEIpIHtcbiAgICBjb25zdCBfZGlmZmVyZW5jZSA9IG5ldyBTZXQoc2V0QSk7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIHNldEIpIHtcbiAgICAgICAgX2RpZmZlcmVuY2UuZGVsZXRlKGVsZW0pO1xuICAgIH1cbiAgICByZXR1cm4gX2RpZmZlcmVuY2U7XG59XG4iXSwibmFtZXMiOlsiaW50ZXJzZWN0aW9uIiwic2V0QSIsInNldEIiLCJfaW50ZXJzZWN0aW9uIiwiU2V0IiwiZWxlbSIsImhhcyIsImFkZCIsInVuaW9uIiwiX3VuaW9uIiwiZGlmZmVyZW5jZSIsIl9kaWZmZXJlbmNlIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_server)/./node_modules/langchain/dist/util/set.js\n");

/***/ })

};
;